package com.raggamuffin.protorunnerv2.gameobjects;


import java.util.ArrayList;

import com.raggamuffin.protorunnerv2.audio.GameAudioManager;
import com.raggamuffin.protorunnerv2.colours.ColourBehaviour;
import com.raggamuffin.protorunnerv2.gamelogic.AffiliationKey;
import com.raggamuffin.protorunnerv2.gamelogic.GameLogic;
import com.raggamuffin.protorunnerv2.managers.GameObjectManager;
import com.raggamuffin.protorunnerv2.pubsub.PubSubHub;
import com.raggamuffin.protorunnerv2.renderer.ModelType;
import com.raggamuffin.protorunnerv2.utils.Colour;
import com.raggamuffin.protorunnerv2.utils.Colours;
import com.raggamuffin.protorunnerv2.utils.Vector3;
import com.raggamuffin.protorunnerv2.utils.Vector4;

public abstract class GameObject 
{
	///// Position and orientation vectors
    protected Vector3 m_Position;		// Position of the GameObject.
	private Vector3 m_PreviousPosition;	// Used in collision detection.
	protected Vector3 m_Forward;		// Forward vector of the GameObject
    protected Vector3 m_Backward;
	protected Vector3 m_Up;				// Up vector of the GameObject.
	protected Vector3 m_Left;			// Left vector of the GameObject.
    protected Vector3 m_Right;
	protected Vector3 m_Scale;			// The scale of the GameObject.
	protected Vector3 m_Velocity;		// Velocity of the GameObject.
	protected Vector3 m_Force;			// The force being applied to the GameObject.
	protected Vector3 m_Acceleration;	// Acceleration of GameObject
	protected double m_Yaw;	            // The orientation of the GameObject in the x-z plane
    protected double m_Roll;            // The orientation of the GameObject in the x-y plane
    protected double m_Pitch;           // The orientation of the GameObject in the y-z plane

	///// Physics Attributes
	protected double m_Mass;			// The mass of the vehicle.
	protected double m_DragCoefficient;	// How much air resistance is generated by the vehicle.
	
	///// Colour Attributes
	protected Colour m_Colour;			// Colour of the GameObject.
	protected Colour m_BaseColour;		// Original colour of the GameObject.
    protected Colour m_AltColour;       // The Alternate colour of the GameObject.
	private Vector4 m_DeltaColour; 		// The colour to be added to the base colour resulting in the actual colour of the game object. Uses a vector3 because the colour class doesn't support numbers outside of the range 0 - 1.
	private ArrayList<ColourBehaviour> m_ColourBehaviours;	// Contains all colour behaviours active on this game object.

	///// Misc Attributes.
	protected double m_BoundingRadius;	// The bounding radius of the game object. Used in collision detection.	
	protected ModelType m_Model;				// What model the gameobject is using to render.
	private AffiliationKey m_Faction;
	protected PubSubHub m_PubSubHub;
	protected GameAudioManager m_GameAudioManager;
	private final GameObjectManager m_GameObjectManager;
	
	protected boolean m_ForciblyInvalidated;

	public GameObject(GameLogic game, ModelType modelType)
	{
		///// Position and orientation vectors.
		m_Position 			= new Vector3(0,0,0);
		m_PreviousPosition 	= new Vector3(0,0,0);
		m_Forward 			= new Vector3(0,0,1);
        m_Backward          = new Vector3(0,0,-1);
		m_Up 				= new Vector3(0,1,0);
		m_Left 				= new Vector3(-1,0,0);
        m_Right             = new Vector3(1,0,0);
		m_Scale 			= new Vector3(1.0);
		m_Velocity 			= new Vector3();
		m_Force 			= new Vector3();
		m_Acceleration  	= new Vector3();
		m_Yaw = 0.0;
        m_Roll = 0.0;
        m_Pitch = 0.0;

		///// Physics Attributes
		m_Mass				 = 100.0;
		m_DragCoefficient	 = 0.85;

		///// Colour Attributes.
		m_BaseColour  = new Colour(Colours.Cyan);
        m_AltColour   = new Colour(Colours.Magenta);
		m_Colour  	  = new Colour(Colours.Cyan);
		m_DeltaColour = new Vector4();
		m_ColourBehaviours = new ArrayList<>();

        ///// Misc Attributes.
		m_BoundingRadius = 1.0;

		SetAffiliation(AffiliationKey.Neutral);

		m_Model = modelType;
		m_PubSubHub = game.GetPubSubHub();
		m_GameAudioManager = game.GetGameAudioManager();
		m_GameObjectManager = game.GetGameObjectManager();
		
		m_ForciblyInvalidated = false;
	}

	public void Update(double deltaTime)
	{
		CalculateAcceleration(deltaTime);
		CalculateVelocity();
        ApplyDrag();
		UpdatePosition(deltaTime);
        UpdateColours(deltaTime);
		
		CleanUpForces();
	}

    protected void CalculateAcceleration(double deltaTime)
    {
        m_Acceleration.I = (m_Force.I / m_Mass) * deltaTime;
        m_Acceleration.J = (m_Force.J / m_Mass) * deltaTime;
        m_Acceleration.K = (m_Force.K / m_Mass) * deltaTime;
    }

    protected void CalculateVelocity()
    {
        m_Velocity.I += m_Acceleration.I;
        m_Velocity.J += m_Acceleration.J;
        m_Velocity.K += m_Acceleration.K;
    }

    private void ApplyDrag()
    {
        m_Velocity.Scale(m_DragCoefficient);
    }
	
	private void UpdatePosition(double deltaTime)
    {
        m_PreviousPosition.SetVector(m_Position);

        m_Position.I += m_Velocity.I * deltaTime;
        m_Position.J += m_Velocity.J * deltaTime;
        m_Position.K += m_Velocity.K * deltaTime;
	}

	protected void UpdateVectorsWithForward(Vector3 forward)
	{
        m_Forward.SetVector(forward);
		UpdateVectors();
	}

	protected void UpdateVectors()
	{
		m_Backward.SetVectorAsInverse(m_Forward);

		m_Right.SetAsCrossProduct(Vector3.UP, m_Forward);
		m_Left.SetVectorAsInverse(m_Right);

		m_Up.SetAsCrossProduct(m_Right, m_Forward);
	}
	
	public void ApplyForce(Vector3 direction, double force)
	{
		m_Force.I += direction.I * force;
		m_Force.J += direction.J * force;
		m_Force.K += direction.K * force;
	}

	public void ApplyForce(Vector3 force)
	{
		m_Force.Add(force);
	}

    private void UpdateColours(double deltaTime)
    {
        m_Colour.SetColour(m_BaseColour);
        m_DeltaColour.SetVector(0.0);

        for (ColourBehaviour Behaviour : m_ColourBehaviours)
        {
            Behaviour.Update(deltaTime);
            m_DeltaColour.Add(Behaviour.GetDeltaColour());
        }

        m_Colour.Add(m_DeltaColour);
    }

    protected void AddColourBehaviour(ColourBehaviour behaviour)
    {
        m_ColourBehaviours.add(behaviour);
	}
	
	public void RemoveColourBehaviour(ColourBehaviour behaviour)
    {
        m_ColourBehaviours.remove(behaviour);
    }

	private void CleanUpForces()
	{
		m_Force.SetVector(0.0f);
	}

	// Each subclass must define when it becomes invalid.
	public abstract boolean IsValid();

	public void ForceInvalidation()
	{
		m_ForciblyInvalidated = true;
	}
	
	protected boolean IsForciblyInvalidated()
	{
		return m_ForciblyInvalidated;
	}

	///// Getters / Setters.
	public double GetYaw()
	{
		return m_Yaw;
	}
	
	public void SetYaw(double yaw)
	{
		yaw = yaw % (Math.PI * 2);
		m_Yaw = yaw;

		m_Forward.SetVector(0, 0, 1);
		m_Forward.RotateY(m_Yaw);

        UpdateVectorsWithForward(m_Forward);
	}

    public double GetRoll()
    {
        return m_Roll;
    }

    public void SetRoll(double roll)
    {
        m_Roll = roll;
    }

    public double GetPitch()
    {
        return m_Pitch;
    }

    public void SetPitch(double pitch)
    {
        m_Pitch = pitch;
    }

	public ModelType GetModel()
	{
		return m_Model;
	}

	public Vector3 GetPosition()
	{
		return m_Position;
	}
	
	public void SetPosition(Vector3 position)
	{
		m_Position.SetVector(position);
	}
	
	public void SetPosition(double x, double y, double z)
    {
        m_Position.SetVector(x, y, z);
	}

	public Vector3 GetPreviousPosition()
	{
		return m_PreviousPosition;
	}
	
	public Vector3 GetForward()
	{
		return m_Forward;
	}

    public Vector3 GetBackward()
    {
        return m_Backward;
    }

	public Vector3 GetUp()
	{
		return m_Up;
	}

    public Vector3 GetRight()
    {
        return m_Right;
    }

	public Vector3 GetVelocity()
	{
		return m_Velocity;
	}
	
	public Vector3 GetScale()
	{
		return m_Scale;
	}
	
	public Colour GetBaseColour()
	{
		return m_BaseColour;
	}
	
	public void SetBaseColour(double[] colour)
	{
        m_BaseColour.SetColour(colour);
		m_Colour.SetColour(m_BaseColour);
	}

	public void SetColourByReference(Colour colour)
	{
		m_Colour = colour;
	}

	public void SetBaseColour(Colour colour)
    {
        SetBaseColour(colour.ToDoubleArray());
	}

    public void SetColourScheme(double[] base, double[] alt)
    {
        m_BaseColour.SetColour(base);
        m_AltColour.SetColour(alt);
        m_Colour.SetColour(m_BaseColour);
    }

	public Colour GetColour()
	{
		return m_Colour;
	}

    public Colour GetAltColour() { return m_AltColour; }

	public double GetBoundingRadius()
	{
		return m_BoundingRadius;
	}

	public void AddObjectToGameObjectManager(GameObject obj)
	{
		m_GameObjectManager.AddObject(obj);
	}

	public void RemoveObjectFromGameObjectManager(GameObject obj)
	{
		m_GameObjectManager.RemoveObject(obj);
	}

	public void SetAffiliation(AffiliationKey faction)
	{
		m_Faction = faction;
	}
	
	public AffiliationKey GetAffiliation()
	{
		return m_Faction;
	}
	
	public double GetMass()
	{
		return m_Mass;
	}
	
	public void SetScale(double scale)
	{
		m_Scale.SetVector(scale);
	}

    public void SetScale(double i, double j, double k)
    {
        m_Scale.SetVector(i, j, k);
    }
	
	public void SetForward(Vector3 forward)
    {
        m_Forward.SetVector(forward);
	}
	
	public void SetDragCoefficient(double drag)
	{
		m_DragCoefficient = drag;
	}

	public double CalculateStress()
	{
		return 0.0;
	}

    public abstract void CleanUp();
}
